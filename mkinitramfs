#!/bin/sh

# Takes a file containing a list of modules to be added as an
# argument, figures out dependancies, and adds them.
#
# Input file syntax:
#
#   # comment
#   modprobe_module_name [args ...]
#   [...]
#
manual_add_modules()
{
	# Sanity check
	if [ ! -e ${1} ]; then
		return
	fi

	sed -e '/^#/d' ${1} | while read module rest; do
		for y in $(modprobe --set-version=${version} --show-depends ${module} | awk '{ print $2 }'); do
			# Prune duplicates
			if [ -e ${DESTDIR}/${y} ]; then
				continue
			fi
	
			mkdir -p ${DESTDIR}/$(dirname ${y})
			ln -s ${y} ${DESTDIR}/$(dirname ${y})
			echo $(basename ${y} .ko) "${rest}" >>${DESTDIR}/conf/modules
		done
	done
}

# Copy entire subtrees to the initramfs
copy_modules_dir()
{
	tmpdir_modbase=${DESTDIR}/lib/modules/${version}
	mkdir -p $(dirname ${tmpdir_modbase}/${1})
	cp -a /lib/modules/${version}/${1} ${tmpdir_modbase}/${1}
}

# Modules that we always add to the initramfs
auto_add_modules()
{
	copy_modules_dir kernel/drivers/net
	copy_modules_dir kernel/drivers/scsi
	copy_modules_dir kernel/drivers/ide
	copy_modules_dir kernel/drivers/md
	copy_modules_dir kernel/drivers/usb
	copy_modules_dir kernel/drivers/block
	copy_modules_dir kernel/drivers/input
	copy_modules_dir kernel/fs/ext2
	copy_modules_dir kernel/fs/ext3
	copy_modules_dir kernel/fs/isofs
	copy_modules_dir kernel/fs/jbd
	copy_modules_dir kernel/fs/jfs
	copy_modules_dir kernel/fs/nfs
	copy_modules_dir kernel/fs/reiserfs
	copy_modules_dir kernel/fs/xfs

	# These aren't caught by the above but really need to be there:
	for x in mbcache nfs af_packet raid1 ide-cd ide-disk ide-generic; do
		for y in $(modprobe --set-version=${version} --show-depends ${x} | awk '{ print $2 }'); do
			# Prune duplicates
			if [ -e ${DESTDIR}/${y} ]; then
				continue
			fi
	
			mkdir -p ${DESTDIR}/$(dirname ${y})
			ln -s ${y} ${DESTDIR}/$(dirname ${y})
			depmod -b ${DESTDIR} ${version}
		done
	done
}

usage()
{
	cat >&2 << EOF

Usage: ${0} [OPTION]... <-o outfile> [version]

Options:
  -d confdir  Specify an alternative configuration directory.
  -k          Keep temporary directory used to make the image.
  -o outfile  Write to outfile.
  -r root     Override ROOT setting in mkinitrd.conf.

See ${0}(8) for further details.
EOF
	exit 1

}

# Defaults
keep="n"
CONFDIR="/etc/mkinitramfs"
verbose="n"
errors_to="2>/dev/null"

while getopts "d:ko:r:" flag; do
	case $flag in
	d)
		CONFDIR="${OPTAGS}"
		if [ ! d "${CONFDIR}" ]; then
			echo "${0}: ${CONFDIR}: Not a directory" >&2
			exit 1
		fi
		;;
	o)
		outfile="${OPTARG}"
		;;
	k)
		keep="y"
		;;
	esac
done

shift $((${OPTIND} - 1))

# For dependency ordered mkinitramfs hook scripts.
. /usr/share/initramfs-tools/scripts/functions

. ${CONFDIR}/initramfs.conf

if [ x${outfile} = x ]; then
	usage
fi

# And by "version" we really mean path to kernel modules
# This is braindead, and exists to preserve the interface with mkinitrd
if [ ${#} -ne 1 ]; then
	version=$(uname -r)
else 
	version="${1}"
fi

case ${version} in
/lib/modules/*/[!/]*)
        ;;
/lib/modules/[!/]*)
        version=${version#/lib/modules/}
        version=${version%%/*}
        ;;
esac

case ${version} in
*/*)
        echo $PROG: ${version} is not a valid kernel version >&2
        exit 1
        ;;
esac

if [ -d ${outfile} ]; then
	echo "${outfile} is a directory"
	exit 1
fi

if [ ! -e /lib/modules/${version} ]; then
	echo "Cannot find /lib/modules/${version}"
	exit 1
fi

DESTDIR=$(mktemp -t -d mkinitramfs_XXXXXX) || exit 1
__TMPCPIOGZ=$(mktemp -t mkinitramfs-OL_XXXXXX) || exit 1

# Export environment for hook scripts.
#
export version
export CONFDIR
export DESTDIR

# Private, used by 'catenate_cpiogz'.
export __TMPCPIOGZ

for d in bin conf etc lib modules sbin scripts; do
    mkdir -p ${DESTDIR}/${d}
done

for x in ${CONFDIR}/modules /usr/share/initramfs-tools/modules.d/*; do
	manual_add_modules ${x}
done

auto_add_modules

# Have to do each file, because cpio --dereference doesn't recurse down
# symlinks.

ln -s /usr/lib/klibc/bin/* ${DESTDIR}/bin
ln -s /usr/lib/klibc/lib/* ${DESTDIR}/lib
ln -s /usr/share/initramfs-tools/init ${DESTDIR}/init
cp -a /usr/share/initramfs-tools/scripts/* ${DESTDIR}/scripts
ln -s ${CONFDIR}/initramfs.conf ${DESTDIR}/conf
ln -s /etc/udev ${DESTDIR}/etc

# Hack until udev is built with klibc
ln -s /sbin/udev ${DESTDIR}/bin
ln -s /sbin/udevstart ${DESTDIR}/bin
ln -s /lib/libc.so.* ${DESTDIR}/lib
ln -s /lib/ld*.so.* ${DESTDIR}/lib
rm ${DESTDIR}/lib/*lsb*

# Busybox
rm ${DESTDIR}/bin/sh
ln -s /usr/lib/initramfs-tools/bin/busybox ${DESTDIR}/bin/sh
# This is ugly, but needed atm to make the builtins work =(
ln -s /usr/lib/initramfs-tools/bin/busybox ${DESTDIR}/bin/busybox

# Modutils
ln -s /sbin/modprobe ${DESTDIR}/sbin
ln -s /sbin/depmod ${DESTDIR}/sbin
ln -s /sbin/rmmod ${DESTDIR}/sbin
mkdir -p ${DESTDIR}/etc/modprobe.d
ln -s /etc/modprobe.d/aliases ${DESTDIR}/etc/modprobe.d

# Raid
ln -s /sbin/mdadm ${DESTDIR}/sbin
ln -s /sbin/mdrun ${DESTDIR}/sbin

run_scripts /usr/share/initramfs-tools/hooks
run_scripts /etc/mkinitramfs/hooks

(cd ${DESTDIR} && find . | cpio --quiet --dereference -o -H newc | gzip -9 >${outfile})

if [ -s ${__TMPCPIOGZ} ]; then
    cat ${__TMPCPIOGZ} >>${outfile}
fi

if [ "${keep}" = "y" ]; then
	echo "Working files in ${DESTDIR} and overlay in ${__TMPCPIOGZ}"
else
	rm -rf "${DESTDIR}"
	rm -rf "${__TMPCPIOGZ}"
fi

exit 0
