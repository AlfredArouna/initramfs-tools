#!/bin/sh -x

/bin/busybox ln -s /bin/busybox /bin/[
/bin/busybox ln -s /bin/busybox /bin/basename
/bin/busybox ln -s /bin/busybox /bin/mount
/bin/busybox ln -s /bin/busybox /bin/mkdir
/bin/busybox ln -s /bin/busybox /bin/umount
/bin/busybox ln -s /bin/busybox /bin/sed
/bin/busybox ln -s /bin/busybox /bin/grep
/bin/busybox ln -s /bin/busybox /bin/cat

mkdir /sys
mkdir /proc
mkdir /tmp
mount -t sysfs sysfs /sys
mount -t proc proc /proc

. /conf/initramfs.conf
. /scripts/functions

# Parse command line options
init=/sbin/init
root=
ro=-r
break=
rootmnt=/root
for x in $(cat /proc/cmdline); do
	case $x in
	init=*)
		INIT=${x#init=}
		;;
	root=*)
		ROOT=${x#root=}
		;;
	nfsroot=*)
		NFSROOT=${x#nfsroot=}
		;;
	boot=*)
		BOOT=${x#boot=}
		;;
	ro)
		ro=-r
		;;
	rw)
		ro=-w
		;;
	break)
		break=yes
		;;
	esac
done

run_scripts /scripts/init-top

. /scripts/${BOOT}

# Load the modules
# FIXME - do module options here
for x in $(cat /conf/modules); do
	insmod /modules/$x
done

# Populate /dev tree
udevstart

if [ x${break} = xyes ]; then 
	panic "Spawning shell within the initramfs"
fi

mountroot

run_scripts /scripts/init-bottom

umount /sys
umount /proc

# Chain to real filesystem
exec run-init ${rootmnt} ${init} "$@"
