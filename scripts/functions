panic()
{
	echo $@
	FS1='(initramfs) ' exec /bin/sh
}

render()
{
	eval "echo -n \${$@}"
}

set_initlist()
{
	unset initlist
	for si_x in ${initdir}/*; do
		if [ ! -x ${si_x} ]; then
			continue
		fi
		initlist="${initlist} $(basename ${si_x})"
	done
}

reduce_satisfied()
{
	deplist="$(render array_${1})"
	for rs_x in ${runlist}; do
		pop_list_item ${rs_x} ${deplist}
		deplist=${tmppop}
	done
	eval array_${1}=\"${deplist}\"
}

get_prereqs()
{
	set_initlist
	for gp_x in ${initlist}; do
		tmp=$(${initdir}/${gp_x} prereqs)
		eval array_${gp_x}=\"${tmp}\"
	done
}

count_unsatisfied()
{
	set - ${@}
	return ${#}
}

# Removes $1 from initlist
pop_list_item()
{
	item=${1}
	shift
	set - ${@}
	unset tmppop
	# Iterate
	for pop in ${@}; do
		if [ ${pop} = ${item} ]; then
			continue
		fi
		tmppop="${tmppop} ${pop}"
	done

}

# This function generates the runlist, so we clear it first.
reduce_prereqs()
{
	unset runlist
	set_initlist
	set - ${initlist}
	i=$#
	# Loop until there's no more in the queue to loop through
	while [ ${i} -ne 0 ]; do
		oldi=${i}
		for rp_x in ${initlist}; do
			reduce_satisfied ${rp_x}
			count_unsatisfied $(render array_${rp_x})
			cnt=${?}
			if [ ${cnt} -eq 0 ]; then
				runlist="${runlist} ${rp_x}"
				pop_list_item ${rp_x} ${initlist}
				initlist=${tmppop}
				i=$((${i} - 1))
			fi
		done
		if [ ${i} -eq ${oldi} ]; then
			echo "PANIC: Circular dependancy.  Exiting." >&2
			exit 1
		fi
	done
}

call_scripts()
{
	echo ${runlist}
	for cs_x in ${runlist}; do
		${initdir}/${cs_x}
	done
}

run_scripts()
{
	initdir=${1}
	get_prereqs
	reduce_prereqs
	call_scripts
}

load_modules()
{
	depmod

	for x in /sys/bus/pci/devices/*; do
		modprobe -q $(cat ${x}/modalias)
	done

	# Give the USB bus a moment to catch up
	sleep 2

	for x in /sys/bus/usb/devices/*; do
		modprobe -q $(cat ${x}/modalias)
	done

	# Load the modules
	# FIXME - do module options here
	for x in $(cat /conf/modules); do
		modprobe -v $x
	done
}
