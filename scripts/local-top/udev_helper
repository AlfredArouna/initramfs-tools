#!/bin/sh

PREREQ=""

prereqs()
{
	echo "$PREREQ"
}

case $1 in
# get pre-requisites
prereqs)
	prereqs
	exit 0
	;;
esac

# Our job now is to make the block device for the root filesystem available.
# This is actually a bit trickier than it first appears because we first need
# to figure out which driver needs it, and to do that, we need to know what
# type of bus it's on.  Fortunately we have all that information, this still
# feels like an ungodly hack though.
case "${ROOT}" in
/dev/root)
	# An interesting case, this root device was specified as a
	# major/minor pair.  Fortunately we have that information
	case "${major}" in
	3|22|33|34|56|57|88|89|90|91)
		# traditional ide
		root_type=ide
		;;
	80|81|82|83|84|85|86|87)
		# ide on i2o
		root_type=ide
		;;
	8|11|65|66|67|68|69|70|71|128|129|130|131|132|133|134|135)
		# scsi
		root_type=scsi
		;;
	esac
	;;
/dev/hd*)
	# Ahh, plain-old traditional ide
	root_type=ide
	;;
/dev/sd*)
	# SCSI, or an IDE controller dressed up in drag
	root_type=scsi
	;;
/dev/disk/*)
	# Specified by label; sadly there's no way to tell what bus
	# this is on, so we'll just declare that we only support it
	# for SCSI and removable devices
	root_type=scsi
	;;
esac

case "${root_type}" in
ide)
	# If we're booting from IDE, it might not be a PCI controller,
	# but might be an old fashioned ISA controller; in which case
	# we need to load ide-generic.
	if [ ! -e "${ROOT}" -o "${ROOT}" = "/dev/root" ]; then
	    modprobe -q ide-generic
	fi
	;;

scsi)
	# If we're booting from SCSI we should have done all we need,
	# now it's just a matter of waiting for the devices to appear
	# which could take a while...
	[ -e "${ROOT}" ] || log_begin_msg "Waiting for root file system"

	if type usplash_write >/dev/null 2>&1; then
	    usplash_write "TIMEOUT 30" || true
	fi

	slumber=300
	while [ ${slumber} -gt 0 -a ! -e "${ROOT}" ]; do
	    /bin/sleep 0.1
	    slumber=$(( ${slumber} - 1 ))
	done

	if type usplash_write >/dev/null 2>&1; then
	    usplash_write "TIMEOUT 15" || true
	fi

	if [ ${slumber} -gt 0 ]; then
	    log_end_msg 0
	else
	    log_end_msg 1 || true
	fi
	;;
esac
